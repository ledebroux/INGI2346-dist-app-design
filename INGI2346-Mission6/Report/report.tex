\documentclass{article}

\input{header.tex}

\begin{document}

\begin{titlepage}
    \begin{center}
        {\huge LINGI2346 - Distributed application design}\\
        \vspace{0.4cm}
        
        {\Large {Teacher : Marc Lobelle}}\\
        \vspace{0.6cm}
        
        {\Large \textit{Problem 5: Parallel Virtual Machine}}\\
        \vspace{1.2cm}

        \texttt{}\\
        \vspace{0.2cm}

        \includegraphics[height=10cm]{pageGarde.png}\\
        \vspace{0.1cm}
        {\Large \textbf{Universit\'e Catholique de Louvain}}
        \vspace{0.3cm}

        \vspace{2cm}
        Group 24\\
        \vspace{0.3cm}
        LÃ©onard Debroux\\
        Thibaut Knop\\
        \vspace{0.4cm}
        2013-2014\\
    \end{center}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%TITRE ET TABLE DES MATIERES%%%%%%%%%%%%%%%%%%
%\maketitle
%\tableofcontents
%\addcontentsline{toc}{section}{ }
\newpage

%Write a narrative describing how you went about writing and testing each program you write. The narrative should describe what choices you faced and which you made. We should get a pretty good sense of what your program looks like from reading the narrative. So far as testing goes, describe how you went about choosing your test cases, what they were, and their results.

\section{Reasoning for the implementation of the algorithm}
The election algorithm is implemented as follows : 
\begin{enumerate}
\item The main task will spawn different \verb@pvm@ tasks corresponding to the nodes of the graph. Before spawning the new nodes, it will compute the diameter of the graph, the number of outgoing edges and ingoing edges for each nodes. After spawning the nodes, the main task send theses precomputed information to each node.
\item Each newly spawned node will send back its \verb@tid@ to the main task, who is gonna compute for each node, the list of reachable \verb@tids@ and the list of \verb@tids@ that can reach them. The main task then sends this information to each node.
\item Before each node initiates the election protocol, they have to wait for a \verb@start@ message from the main task. This message is sent only when all tasks are spawned and aware of the nodes they can reach or by which nodes they can be reached. This sort of \textit{synchronisation} between nodes is necessary to ensure consistency of the informations across the graph at the beginning of the election protocol.
\item First, each \verb@pvm@ tasks corresponding to the different nodes of the graph send the value of their \verb@max_id@ variable to their children (i.e. the nodes that it can reach, linked by an outgoing edge).
\item Then each nodes wait for the \verb@max_id@ value from their parents (i.e. the nodes linked by an ingoing edge). However, it is not sufficient to wait for \verb@n@ messages, where \verb@n@ represents the number of parents. Indeed, it is somehow possible and it happens that a parent node will send twice its \verb@max_id@ while another one has not yet sent its first \verb@max_id@. Therefore, we force the nodes to wait for messages from specific \verb@tid@, in a certain order. Therefore, we are sure to receive exactly one message per parents node at each round of the election protocol. Regarding the value of the \verb@max_id@ value, if the value received from a parents node is bigger than the value of the \verb@max_id@ of the receiver, then the \verb@max_id@ is updated to this new value.
\item TODO : we have to synchronise all rounds of the election protocol for each node... WHY ? HOW ? ( At the end of each round of the election protocol, the \verb@pvm@ tasks send back their \verb@tid@ to the main task to advertise it of the end of a round. The main task waits for the \verb@tid@ of each node before multicasting a \verb@go@ message to the node, meaning that they can pursue with the next round.
\end{enumerate}

\section{Discussion of the problems involved in the use of the groups of processes}

\section{The source code directory and instruction for building the executable files}
In the \verb@code@ folder, here are the files you can find : 
\begin{description}
\item[config] Contains the initial configuration for the \verb@pvm@ process. Here it contains only the path to the executables, for any machines names. It avoids to have to place the executables in the \verb@PVM_ARCH@ directory of the \verb@pvm@ directory.
\item[election.c] Contains the code for the main tasks that will create the different \verb@pvm@ tasks associated with each node and compute the \verb@diameter@ of the graph. More practically, it parses the input graph, then creates the pvm tasks associated to each node, compute the diameter ans makes the nodes aware of the others nodes they can reach.
\item[node.c] Contains the code for the different nodes of the graph : first the node are created, then they start the election algorithm.
\item[graph.txt] Contains the description of the graph : the first line is dedicated to the number of nodes in the graph, the second line is dedicated to the number of edges in the graph, and the third line is dedicated to describe how nodes are connected in the following form : \verb@{n1, n2},{n1,n3},{n2,n3}@, which means that \verb@n1@ has an outgoing edge toward \verb@n2@ and \verb@n3@, and that \verb@n2@ has one towards \verb@n3@. The number of edge is limited to 200.
\end{description}

To build the executable files, please execute the \verb@makefile@ that you can find at the root of the directory (\verb@./make@). The \verb@makefile@ compiles \verb@election.c@ and \verb@node.c@.\\

To try the program, please launch \verb@./make@, then start \verb@pvm@ with the \verb@config@ file (\verb@pvm config@). Please modify the \verb@config@ file by replacing the path to the \verb@code@ folder to yours. Then modify the graph configuration if u want, and launch \verb@./election graph.txt@ by providing the graph configuration file.

\section{Commented listings of the programs}
Here are all the files for the election protocol to work.

\lstinputlisting{../code/node.c}
\lstinputlisting{../code/election.c}
\lstinputlisting{../code/config}
\lstinputlisting{../code/graph.txt}
\lstinputlisting{../code/Makefile}


\end{document}

